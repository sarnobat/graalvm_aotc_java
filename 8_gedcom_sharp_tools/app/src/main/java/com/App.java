/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Stream;

import org.antlr.runtime.ANTLRInputStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.TreeVisitor;
import org.antlr.runtime.tree.TreeVisitorAction;
import org.gentoo.libbash.java_libbashLexer;
import org.gentoo.libbash.java_libbashParser;

/**
 * Unlike some rudimentary regex, we parse the bash script properly so that whitespace 
 * inside legitimate commands gets interpreted correctly.
 */
public class App {

	public static void main(String[] args) throws ClassNotFoundException, FileNotFoundException, IOException,
			RecognitionException, InterruptedException {
		Set<String> visited = new HashSet<String>();
		java_libbashParser theParser = new java_libbashParser(new CommonTokenStream(
				new java_libbashLexer(new ANTLRInputStream(new FileInputStream(Paths.get(getArg(args)).toFile())))));
		Stream<String> s1 = Stream.of();
		ConcurrentLinkedQueue<String> q = new ConcurrentLinkedQueue<>();
		Thread t = new Thread() {

			@Override
			public void run() {
				try {
					extracted(theParser, s1, q);
				} catch (RecognitionException e) {
					e.printStackTrace();
				}
			}

		};
		t.start();
		t.join();
		// I don't think it's possible to use a stream instead of a queue.
		// Streams need to be closed before being consumed, apparently.
		while (!q.isEmpty()) {
			String symbol = q.remove();
			if (visited.contains(symbol)) {
				continue;
			}
			visited.add(symbol);
			
			if (symbol.startsWith("-")) {
				continue;
			} else if (symbol.startsWith("$")) {
				continue;
			}
			System.out.println(symbol);
		}

	}

	private static void debug(String msg) {
		if (false) {
			System.err.println(msg);
		}
	}

	private static String getArg(String[] args) {
		String script;
		if (args.length < 1) {
			script = System.getProperty("user.home") + "/bin/du_inodes.sh";
			debug("[warn] No input file specified, using " + script);
		} else {
			script = args[0];
		}
		return script;
	}

	private static void extracted(java_libbashParser theParser, Stream<String> s1, ConcurrentLinkedQueue<String> q)
			throws RecognitionException {
		new TreeVisitor(theParser.getTreeAdaptor()).visit(theParser.start().getTree(), new TreeVisitorAction() {
			public Object pre(Object iObject) {
				return iObject;
			}

			public Object post(Object iObject) {

				if (iObject instanceof CommonTree) {
					CommonTree aTreeObject = (CommonTree) iObject;
					int aType = aTreeObject.getType();
					if (aType == java_libbashParser.STRING) {

						StringBuffer aStringBuffer = new StringBuffer();
						for (Object child : aTreeObject.getChildren()) {
							CommonTree aChildTree = (CommonTree) child;
							if (aChildTree.getText().equals("SINGLE_QUOTED_STRING")) {
								// don't add this, just add what's inside it
							} else if (aChildTree.getText().equals("DOUBLE_QUOTED_STRING")) {
								// don't add this, just add what's inside it
							} else if (aChildTree.getText().equals("COMMAND_SUB")) {
								// don't add this, just add what's inside it
							} else if (aChildTree.getText().equals("VAR_REF")) {
								// don't add this, just add what's inside it
							} else {
								aStringBuffer.append(aChildTree.getText());
							}
						}
						if (aStringBuffer.length() > 0) {
							q.add(aStringBuffer.toString());
						}
						debug("App.extracted(...).new TreeVisitorAction() {...}.post() STRING - "
								+ aStringBuffer.toString());
					} else if (aType == java_libbashParser.RBRACE) {
					} else if (aType == java_libbashParser.USE_DEFAULT_WHEN_UNSET_OR_NULL) {
					} else if (aType == java_libbashParser.VARIABLE_DEFINITIONS) {
					} else if (aType == java_libbashParser.VAR_REF) {
					} else if (aType == java_libbashParser.LSHIFT) {
					} else if (aType == java_libbashParser.ARRAY_SIZE) {
					} else if (aType == java_libbashParser.OP) {
					} else if (aType == java_libbashParser.MATCH_ANY) {
					} else if (aType == java_libbashParser.COMMAND_SUB) {
						//						System.out.println("App.extracted(...).new TreeVisitorAction() {...}.post()  - are we coming here?");
						//						System.exit(-1);
					} else if (aType == java_libbashParser.DOUBLE_QUOTED_STRING) {
					} else if (aType == java_libbashParser.SINGLE_QUOTED_STRING) {
						//
						//						StringBuffer aStringBuffer = new StringBuffer();
						//						for (Object child : aTreeObject.getChildren()) {
						//							CommonTree aChildTree = (CommonTree) child;
						//							aStringBuffer.append(aChildTree.getText());
						//						}
						//						q.add(aStringBuffer.toString());
					} else if (aType == java_libbashParser.NAME) {
					} else if (aType == java_libbashParser.COMMAND) {
					} else if (aType == java_libbashParser.LIST) {
						for (Object aChild : aTreeObject.getChildren()) {
							CommonTree aChildTree = (CommonTree) aChild;
							debug(
									"App.main() LIST aChildTree.toStringTree() = " + aChildTree.toStringTree());
						}

					} else if (aType == java_libbashParser.CURRENT_SHELL) {
					} else if (aType == java_libbashParser.SLASH) {
					} else if (aType == 2) {
						// pipe
					} else {
						debug("App.main() UNKNOWN 4 treeObject.getLine() = " + aTreeObject.getLine());
						debug("App.main() UNKNOWN 4 treeObject.getText() = " + aTreeObject.getText());
					}

				} else {
					debug("App.main() " + iObject.getClass());
				}
				return iObject;
			}
		});
	};
}
